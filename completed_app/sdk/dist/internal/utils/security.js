"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSecurityProperties = void 0;
var securityMetadataKey = "security";
function parseSecurityProperties(security) {
    return parseSecurityClass(security);
}
exports.parseSecurityProperties = parseSecurityProperties;
function parseSecurityDecorator(securityAnn) {
    // scheme=true;type=apiKey;subtype=header"
    var option = false;
    var scheme = false;
    var name = "";
    var securityType = "";
    var securitySubType = "";
    securityAnn.split(";").forEach(function (securityAnnPart) {
        var _a = __read(securityAnnPart.split("="), 2), sKey = _a[0], sVal = _a[1];
        switch (sKey) {
            case "name":
                name = sVal;
                break;
            case "type":
                securityType = sVal;
                break;
            case "subtype":
                securitySubType = sVal;
                break;
            case "option":
                option = sVal == "true";
                break;
            case "scheme":
                scheme = sVal == "true";
        }
    });
    return new SecurityDecorator(name, securityType, option, scheme, securitySubType);
}
function parseSecurityClass(security) {
    var fieldNames = Object.getOwnPropertyNames(security);
    var properties = {
        params: {},
        headers: {},
    };
    fieldNames.forEach(function (fname) {
        var securityAnn = Reflect.getMetadata(securityMetadataKey, security, fname);
        if (securityAnn == null)
            return;
        var securityDecorator = parseSecurityDecorator(securityAnn);
        if (securityDecorator == null)
            return;
        var value = security[fname];
        if (securityDecorator.Option) {
            return parseSecurityOption(properties, value);
        }
        else if (securityDecorator.Scheme) {
            if (securityDecorator.SubType === "basic" && value !== Object(value)) {
                return parseSecurityScheme(properties, securityDecorator, security);
            }
            else {
                return parseSecurityScheme(properties, securityDecorator, value);
            }
        }
    });
    return properties;
}
function parseSecurityOption(properties, optionType) {
    var fieldNames = Object.getOwnPropertyNames(optionType);
    fieldNames.forEach(function (fname) {
        var securityAnn = Reflect.getMetadata(securityMetadataKey, optionType, fname);
        if (securityAnn == null)
            return;
        var securityDecorator = parseSecurityDecorator(securityAnn);
        if (securityDecorator == null || !securityDecorator.Scheme)
            return;
        return parseSecurityScheme(properties, securityDecorator, optionType[fname]);
    });
}
function parseSecurityScheme(properties, schemeDecorator, scheme) {
    if (scheme === Object(scheme)) {
        if (schemeDecorator.Type === "http" &&
            schemeDecorator.SubType === "basic") {
            return parseBasicAuthScheme(properties, scheme);
        }
        var fieldNames = Object.getOwnPropertyNames(scheme);
        fieldNames.forEach(function (fname) {
            var securityAnn = Reflect.getMetadata(securityMetadataKey, scheme, fname);
            if (securityAnn == null)
                return;
            var securityDecorator = parseSecurityDecorator(securityAnn);
            if (securityDecorator == null || securityDecorator.Name === "")
                return;
            return parseSecuritySchemeValue(properties, schemeDecorator, securityDecorator, scheme[fname]);
        });
    }
    else {
        return parseSecuritySchemeValue(properties, schemeDecorator, schemeDecorator, scheme);
    }
}
function parseSecuritySchemeValue(properties, schemeDecorator, securityDecorator, value) {
    switch (schemeDecorator.Type) {
        case "apiKey":
            switch (schemeDecorator.SubType) {
                case "header":
                    properties.headers[securityDecorator.Name] = value;
                    break;
                case "query":
                    properties.params[securityDecorator.Name] = value;
                    break;
                case "cookie": {
                    var securityDecoratorName = securityDecorator.Name;
                    var val = value;
                    properties.headers["Cookie"] = "".concat(securityDecoratorName, "=").concat(val);
                    break;
                }
                default:
                    throw new Error("not supported");
            }
            break;
        case "openIdConnect":
            properties.headers[securityDecorator.Name] = value;
            break;
        case "oauth2":
            properties.headers[securityDecorator.Name] = value;
            break;
        case "http":
            switch (schemeDecorator.SubType) {
                case "basic":
                    break;
                case "bearer":
                    properties.headers[securityDecorator.Name] = value.toLowerCase().startsWith("bearer ") ? value : "Bearer ".concat(value);
                    break;
                default:
                    throw new Error("not supported");
            }
            break;
        default:
            throw new Error("not supported");
    }
}
function parseBasicAuthScheme(properties, scheme) {
    var username, password = "";
    var fieldNames = Object.getOwnPropertyNames(scheme);
    fieldNames.forEach(function (fname) {
        var securityAnn = Reflect.getMetadata(securityMetadataKey, scheme, fname);
        if (securityAnn == null)
            return;
        var securityDecorator = parseSecurityDecorator(securityAnn);
        if (securityDecorator == null || securityDecorator.Name === "")
            return;
        switch (securityDecorator.Name) {
            case "username":
                username = scheme[fname];
                break;
            case "password":
                password = scheme[fname];
                break;
        }
    });
    properties.headers["Authorization"] = "Basic ".concat(Buffer.from("".concat(username, ":").concat(password)).toString('base64'));
}
var SecurityDecorator = /** @class */ (function () {
    function SecurityDecorator(Name, Type, Option, Scheme, SubType) {
        this.Name = Name;
        this.Type = Type;
        this.Option = Option;
        this.Scheme = Scheme;
        this.SubType = SubType;
    }
    return SecurityDecorator;
}());
